[{"title":"JavaScript排序算法及性能比较","date":"2017-03-30T02:23:43.000Z","path":"2017/03/30/JavaScript排序算法及性能比较/","text":"作者原文：http://www.boatsky.com/blog/10.html 说到算法，对很多同学来说，启蒙算法应该就是冒泡排序，我们也会见到它解决排序问题，然后，数据量稍大时，它就显的无力了。前端可能用到算法的机会不算多，但用到时又不会，临时去学，就有些痛苦了。 算法很大程度是数学问题，而算法的作者们往往是一些科学家或大牛，这确实需要良好的数学功底。但不要被它吓到，站在巨人的肩膀上，花些时间理解已有理论，就可以直接或间接使用现成算法解决问题，人类的智慧成长不正是代代智慧的叠加么？所以私以为学习算法，并不需要多好的数学素养。 前言 说到算法，对很多同学来说，启蒙算法应该就是冒泡排序，我们也会见到它解决排序问题，然后，数据量稍大时，它就显的无力了。前端可能用到算法的机会不算多，但用到时又不会，临时去学，就有些痛苦了。 算法很大程度是数学问题，而算法的作者们往往是一些科学家或大牛，这确实需要良好的数学功底。但不要被它吓到，站在巨人的肩膀上，花些时间理解已有理论，就可以直接或间接使用现成算法解决问题，人类的智慧成长不正是代代智慧的叠加么？所以私以为学习算法，并不需要多好的数学素养。 算法一般都是C/C++或者伪代码讲解，本文则使用JavaScript翻译一遍，大前端时代嘛。本文参考了《数据结构与算法JavaScript描述》。 1.冒泡排序冒泡排序是最简单的排序算法，效率也是最低的，它把相邻元素两两对比，比较n轮，每轮len-n次，以下都以数组5,1,7,0,9,2,3,8,4,6从小到大排序为例5,1,7,0,9,2,3,8,4,61,5,7,0,9,2,3,8,4,6 1轮,1次，比较5,1的结果1,5,7,0,9,2,3,8,4,6 1轮,2次，比较5,7的结果1,5,0,7,9,2,3,8,4,6 1轮,3次，比较7,0的结果1,5,0,7,9,2,3,8,4,6 1轮,4次，比较7,9的结果……1,5,0,7,2,3,8,4,9,6 1轮,8次，比较9,4的结果1,5,0,7,2,3,8,4,6,9 1轮,9次，比较9,6的结果第1轮完成，把最大值9移至最后，第2轮开始，我们只需比较8次 1,5,0,7,2,3,8,4,6,9 2轮,1次，比较1,51,0,5,7,2,3,8,4,6,9 2轮,2次，比较5,01,0,5,7,2,3,8,4,6,9 2轮,3次，比较5,71,0,5,2,7,3,8,4,6,9 2轮,4次，比较7,2……重复以上操作，第2轮则把8移至第8位，同理经过n(n+1)/2次比较后，得到最终结果。代码如下：1234567891011121314151617//冒泡排序function bubbleSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var i,j,temp; for(i = 0;i &lt; len;i++)&#123; for(j = 0;j &lt; len - i;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125; return arr;&#125; 2.选择排序选择排序与冒泡排序有点相似之次，就是都需要比较n(n+1)/2次，不过它是把最小的数字，排在最前面，第2小的数字，排在第2位，虽然比较次数与冒泡排序一样，但数据交换次却常常比冒泡排序少很多，所以它的效率比冒泡排序更高一次。演示：5,1,7,0,9,2,3,8,4,61,5,7,0,9,2,3,8,4,6 1轮,1次，比较5,11,5,7,0,9,2,3,8,4,6 1轮,2次，比较1,70,5,7,1,9,2,3,8,4,6 1轮,3次，比较1,0……0,5,7,1,9,2,3,8,4,6 1轮,9次，比较0,6第1轮结束，注意了，第一轮第3次之后虽然会一直比较下去，直到0与6比较，但是0已经是最小的数字了，所以之后比较，都无需进行数据交换，提高了效率，但这是不稳定的。 0,5,7,1,9,2,3,8,4,6 2轮,1次，比较5,70,1,7,5,9,2,3,8,4,6 2轮,2次，比较5,1……0,1,7,5,9,2,3,8,4,6 2轮,8次，比较1,6重复n-1轮，得出最终结果。 1234567891011121314151617//选择排序function selectSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var i,j,temp; for(i = 0;i &lt; len;i++)&#123; for(j = i+1;j &lt; len;j++)&#123; if(arr[i] &gt; arr[j])&#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; return arr;&#125; 3.插入排序插入排序，是把数据一个插入已排序的数组中，只需插入n-1遍。5,1,7,0,9,2,3,8,4,61,5,7,0,9,2,3,8,4,6 1插入[5]中结果1,5,7,0,9,2,3,8,4,6 7插入[1,5]中结果0,1,5,7,9,2,3,8,4,6 0插入[1,5,7]中结果0,1,5,7,9,2,3,8,4,6 9插入[0,1,5,7]中结果……0,1,2,3,4,5,7,8,9,6 4插入[0,1,2,3,5,7,8,9,6]中结果0,1,2,3,4,5,6,7,8,9 6插入[0,1,2,3,4,5,6,7,8,9]中结果一共比较n(n+1)/2次，最坏的情况也需要交换这么多次数据，最好的情况，一次数据交换也不需要，所以它是不稳定的，但一般比选择排序快上一些。 代码如下：12345678910111213141516function insertSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var i,j,temp; for(i = 1;i &lt; len;i++)&#123; temp = arr[i]; j = i; while(j &gt; 0 &amp;&amp; arr[j-1] &gt; temp)&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125; &#125; return arr;&#125; 4.归并排序归并排序，则是把已经排好序的子数组合并成一个大的数组。5,1,7,0,9,2,3,8,4,65, 1, 7, 0, 9, 2, 3, 8, 4, 6step 11,5, 0,7, 2,9, 3,8 4,6step 20,1,5,7, 2,3,8,9, 4,6step 40,1,2,3,5,7,8,9, 4,6 最终0,1,2,3,4,5,6,7,8,9 归并排序相对稳定，并且占用内存少，效率一般也比插入排序高。如数据量巨大，不方便使用太占内存的算法时，归并排序是你的选择！代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function mergeSort(arr)&#123; if (arr.length &lt; 2)&#123; return arr; &#125; var step = 1; var left, right; while(step &lt; arr.length)&#123; left = 0; right = step; while(right + step &lt;= arr.length)&#123; mergeArrays(arr, left, left+step, right, right+step); left = right + step; right = left + step; &#125; if (right &lt; arr.length)&#123; mergeArrays(arr, left, left+step, right, arr.length); &#125; step *= 2; &#125; return arr;&#125;function mergeArrays(arr, startLeft, stopLeft, startRight, stopRight)&#123; var leftArr = new Array(stopLeft - startLeft + 1); var rightArr = new Array(stopRight - startRight + 1); var k = startLeft; for(var i = 0;i &lt; (leftArr.length-1);i++)&#123; leftArr[i] = arr[k]; k++; &#125; k = startRight; for(var i = 0;i &lt; (rightArr.length-1);i++)&#123; rightArr[i] = arr[k]; k++; &#125; rightArr[rightArr.length-1] = Infinity; leftArr[leftArr.length-1] = Infinity; var m = 0,n = 0; for(k = startLeft;k &lt; stopRight;k++)&#123; if (leftArr[m] &lt;= rightArr[n])&#123; arr[k] = leftArr[m]; m++; &#125; else &#123; arr[k] = rightArr[n]; n++; &#125; &#125;&#125; 5.希尔排序希尔排序，又是插入排序的改良版，即分组插入。5,1,7,0,9,2,3,8,4,6g为5时，分成5组5与2比较，1与3比较，7与8比较，0与4比较，9与6比较2,1,7,0,6,5,3,8,4,9g为2时，分成2组5,7,9,3,4与1,0,2,3,6，分别进行插入排序得到3,4,5,7,9与0,1,2,3,6结果为3,0,4,1,5,2,7,3,9,6g为1时，3,4,5,7,9与0,1,2,3,6进行插入排序得到0,1,2,3,4,5,6,7,8,9其并不稳定，但因为使用间隔比较，减少了交换次数，在多数情况，比归并更快一点点。代码如下：12345678910111213141516171819202122232425//希尔排序function shellSort(arr)&#123; if(arr.length &gt; 1)&#123; var len = arr.length; var g,i,j, k,temp; //第几轮分组 for(g = Math.floor(len / 2);g &gt; 0;g = Math.floor(g / 2))&#123; for(i = 0;i &lt; g;i++)&#123; for(j = i + g;j &lt; len;j = j + g)&#123; if(arr[j - g] &gt; arr[j])&#123; temp = arr[j]; k = j - g; while(k &gt;= 0 &amp;&amp; arr[k] &gt; temp)&#123; arr[k + g] = arr[k]; k = k - g; &#125; arr[k + g] = temp; &#125; &#125; &#125; &#125; &#125; return arr;&#125; 6.快速排序快速排序即排序很快速！那为什么它这么快？官方的描述是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。我们用实例来演示一下：5,1,7,0,9,2,3,8,4,6选中第0个元素即5作为中间值(不是大小的中间值，只是确定一个固定比较对象)，比5小的放在左数组，比5大的放在右数组，则变成[1,0,2,3,4]+5+[7,9,8,6]与此同时(不是第二步，整个过程都是在1步完成的)，选中左、右数组的第1个元素作为中间值。(ps: 为了好看，我把中间写成是一个数字，其实它是一个单元素数组)[0] + 1 + [2,3,4] + 5 + [6] + 7 + [9,8]与此同时再分解[0] + 1 + 2 + [3,4] + 5 + [6] + 7 + 9 + [8]同时[0] + 1 + 2 + 3 + [4] + 5 + [6] + 7 + 9 + [8]快的原因就是它使用空间换取时间，不断回调自己。如果数据量太大，其实是不建议这么干的。后面我做了一个小数据量（即10000）的情况下，内存基本没什么影响，使用不同的数据，计算了100次，算出其效率比希尔排序还要快10倍，比冒泡排序快4698倍，数据量越大，其占内存越大，同时，其与其他排序方式的速度差距也越大。123456789101112131415161718192021//快速排序function quickSort(arr) &#123; var len = arr.length; if(len == 0)&#123; return []; &#125; else if(len == 1)&#123; return arr; &#125; var smallArr = []; var largeArr = []; var pivot = arr[0]; for (var i = 1; i &lt; len; i++) &#123; if (arr[i] &lt; pivot) &#123; smallArr.push(arr[i]); &#125; else &#123; largeArr.push(arr[i]); &#125; &#125; return quickSort(smallArr).concat(pivot, quickSort(largeArr));&#125; 以上算法的demo : http://www.boatsky.com/static/js/demo/sort_demo.js 这里写一个简单的程序，对上述算法时间计算，各个数组10000个数字，计算100次，取平均值，此处以快速排序为例 1234567891011121314151617181920212223242526272829303132333435363738//分别是每次的计算的开始时间与结束时间var d1,d2;//保存每次计算的时候var arrTime = [];//随机生成数组元素//以为是计算时间例子//分别是每次的计算的开始时间与结束时间var d1,d2;//保存每次计算的时候var arrTime = [];//随机生成数组元素function getArr()&#123; var arr = []; for(var i = 0;i &lt; 10000;i++)&#123; arr.push(Math.floor(Math.random()*10000)); &#125; return arr;&#125;//快速排序//获取时间function getTime()&#123; //计算100次，取平均值，减小误差 for(var k = 0;k &lt; 100;k++)&#123; var arr = getArr(); d1 = new Date().getTime(); arr = quickSort(arr); d2 = new Date().getTime(); arrTime.push(d2-d1); &#125; var all = 0; for(var m = 0;m &lt; arrTime.length;m++)&#123; all = all + arrTime[m]; &#125; console.log(arrTime); console.log(all/arrTime.length);&#125;getTime(); 统计100次 平均时间(ms) 时间复杂度 空间复杂度 稳定性冒泡排序 704.69 O(n(n+1)/2) O(1) 稳定选择排序 214.31 O(n(n+1)/2) O(1) 稳定插入排序 50.62 O(n)~O(n^2/2) O(1) 不稳定归并排序 2.16 O(n log n) O(n) 稳定希尔排序 1.5 O(n log n) ~ O(n^2) O(1) 不稳定快速排序 0.15 O(n log 2 n) ~ O(n^2) O(log 2 n) ~ O(n) 不稳定 所以说，上述6种常见算法中，快速排序是最快的，但如果数据量太大时，内存占用大，而希尔排序速度较快，占内存小，稳定性略差。多数情况下都推荐这两种。 所以，根据你数据的类型，数据量的大小，机器内存的大小，进行一定的测试，选择最适合你的排序吧。 所以说，不要在任何情况下都用冒泡排序啦！！！","tags":[]},{"title":"使用webpack构建时给window绑定事件的坑","date":"2017-03-28T07:45:25.000Z","path":"2017/03/28/使用webpack构建时给window绑定事件的坑/","text":"使用webpack进行构建，给window绑定了onload的事件，结果竟然死活不触发！各种排除后发现问题所在… 业务js文件index.js 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，无效 $(window).on('load', function()&#123; console.log('页面加载完成了~'); &#125;);&#125;) 打开页面，然后控制台并没有打印出“页面加载完成了~” 难道是使用jquery进行绑定的原因导致事件绑定无效？于是改了代码： 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，还是无效 window.onload = function()&#123; console.log('页面加载完成了~'); &#125;;&#125;) 控制台依然没有打印出预期的结果，苦思良久，改成 123456789101112131415var $ = require('jquery');// 在这里绑定，有效$(window).on('load', function()&#123; console.log('页面加载完成了~ 1');&#125;);// 在这里绑定，也有效window.onload = function()&#123; console.log('页面加载完成了~ 2');&#125;;$(function()&#123; &#125;) 那看来是’$(function(){})’这一段代码的问题了，这段代码并不难理解，当页面的dom结构加载完毕则执行，刚入门是使用’script’标签引入jquery，并没有这样的问题出现。 那么现在看来是使用webpack进行构建的并发症了，至于原因，并没有深究的意愿。 现在页面的js基本都是放在页面底部，程序执行到这里，其实意味着dom结构以及渲染完毕了，个人觉得在js中写’$(function(){})’是没有必要了的","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"使用hexo遇到的一个坑","date":"2017-03-23T03:46:16.000Z","path":"2017/03/23/使用hexo遇到的一个坑/","text":"hexo中首页列表的摘要（excerpt）弄不出来，一直显示全文 修改了N多配置都不生效，官方文档中也没有说明，唯有各种搜索答案，终于找到了！ 原来只需要在文中加入&lt;!-- more --&gt;就可以了，这实在是个大坑！ 12345这就是一个简介&lt;!-- more --&gt; 这里更多的内容 原答案链接","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Express路由","date":"2017-03-22T08:11:33.000Z","path":"2017/03/22/express路由/","text":"一、简介 1、Express 是一个基于 Node.js 平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 2、丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 （ Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架） 3、Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 &nbsp; 二、express环境搭建1、安装nodejs和npm，建议安装淘宝提供的国内镜像cnpm，这样安装比较快 1$ npm install –g cnpm 2、新建一个目录，在目录下执行 1$ cnpm install express --save 3、express环境已经搭建好了 &nbsp; 三、基本路由1、简单版，除了get请求，还有post、put、delete 123456789101112131415161718192021222324252627282930313233343536373839404142var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World! &lt;a href=\"/news\"&gt;to news&lt;/a&gt;');&#125;);app.get('/news', function (req, res) &#123; res.send('this is news. &lt;a href=\"/\"&gt;back&lt;/a&gt;');&#125;).post('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a post request!', data: req.query &#125;);&#125;).put('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a put request!', data: req.query &#125;);&#125;).delete('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a delete request!', data: req.query &#125;);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、字符匹配模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;ab?cd（匹配 acd 和 abcd）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab+cd（匹配 abcd、abbcd、abbbcd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab*cd（匹配 abcd、abxcd、abRABDOMcd、ab123cd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab(cd)?e（匹配 /abe 和 /abcde）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res, next) &#123; // res.send('ab?cd'); _routeStr.push('ab?cd'); next();&#125;);// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res, next) &#123; // res.send('ab+cd'); _routeStr.push('ab+cd'); next();&#125;);// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等app.get('/ab*cd', function(req, res, next) &#123; // res.send('ab*cd'); _routeStr.push('ab*cd'); next();&#125;);// 匹配 /abe 和 /abcdeapp.get('/ab(cd)?e', function(req, res, next) &#123; // res.send('ab(cd)?e'); _routeStr.push('ab(cd)?e'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、正则匹配模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;/a/（匹配任何路径中含有 a 的路径');_routeList.push('&lt;li&gt;/.*fly$/（匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配任何路径中含有 a 的路径：app.get(/a/, function(req, res, next) &#123; _routeStr.push('/a/'); next();&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res, next) &#123; _routeStr.push('/.*fly$/'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、执行多个回调 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var app = express();// 多个回调函数，需指定执行nextapp.get('/b', function (req, res, next) &#123; console.log('this is function b one'); next();&#125;, function (req, res) &#123; console.log('this is function b two'); res.send('Hello from B!');&#125;);// 多个回调传入，需指定执行next，最后必须有sendvar cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/c', [cb0, cb1, cb2]);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 四、中间件router1、通过require导入各种路由配置文件 12345678910111213141516171819202122var express = require('express');var app = express();var _router1 = require('./router/r1.js');var _router2 = require('./router/r2.js');var _router3 = require('./router/r3.js');var _router4 = require('./router/r4.js');app.use('/', _router1);app.use('/r2', _router2);app.use('/r3', _router3);app.use('/r4', _router4);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、简单版 1234567891011121314151617181920var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 3、通过路由中间件控制 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; console.log(req.params, req.params.id == 0); // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0)&#123; res.send('ID：' + req.params.id); &#125; // 负责将控制权交给栈中下一个中间件 else&#123; next(); &#125;&#125;, function (req, res, next) &#123; // 渲染常规页面 res.send('next function ID：' + req.params.id); // 填到下一个路由 // next();&#125;);module.exports = router; 使用router.param 123456789101112131415161718192021222324252627282930var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);var _pid;router.get('/blog/:pid', function (req, res, next) &#123; console.log('get function');&#125;);router.param('pid', function (req, res, next, pid)&#123; console.log('param function'); // console.log(req.query); setTimeout(function()&#123; _pid = pid; res.send('my pid is：' + pid + '&amp;&amp;' + req.query.id); &#125;, 1000); next();&#125;);module.exports = router; 多个参数的情况下 12345678910111213141516171819202122232425262728293031323334353637var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 无效，可能是版本问题// router.param(['id', 'page'], function (req, res, next, value) &#123;// console.log('CALLED ONLY ONCE with', value);// next();// &#125;)router.param('nid', function (req, res, next, value) &#123; console.log('nid：', value); next();&#125;);router.param('page', function (req, res, next, value) &#123; console.log('page：', value); next();&#125;);router.get('/news/:nid/:page', function (req, res, next) &#123; console.log('although this matches'); next();&#125;);router.get('/news/:nid/:page', function (req, res) &#123; console.log('and this matches too'); res.send('ok');&#125;);module.exports = router; &nbsp; 五、静态资源目录也算是属于路由中的一部分，负责静态资源的路径设置 1234567891011121314151617181920212223242526var express = require('express');var app = express();app.use(express.static(__dirname + '/images'));app.use('/pic', express.static(__dirname + '/images'));app.use('/img', express.static(__dirname + '/images'));app.get('/img', function (req, res) &#123; var _html = ''; _html += '&lt;p&gt;/icon.png&lt;/p&gt;&lt;img src=\"/icon.png\" /&gt;'; _html += '&lt;p&gt;/pic/icon.png&lt;/p&gt;&lt;img src=\"/pic/icon.png\" /&gt;'; _html += '&lt;p&gt;/img/icon.png&lt;/p&gt;&lt;img src=\"/img/icon.png\" /&gt;'; res.send(_html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 六、实例源码github express_demo","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"},{"name":"router","slug":"router","permalink":"http://yoursite.com/tags/router/"}]}]